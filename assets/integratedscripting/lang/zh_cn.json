{
    "advancement.integratedscripting.filter_chest": "超强大的物品列表过滤",
    "advancement.integratedscripting.filter_chest.desc": "使用基于脚本的函数过滤从箱子中读取的物品列表。",
    "advancement.integratedscripting.mendesite": "门多石丰富",
    "advancement.integratedscripting.mendesite.desc": "合成一个门多石块，这是集成脚本的基本资源。",
    "advancement.integratedscripting.scripting_disk": "这不是软盘！",
    "advancement.integratedscripting.scripting_disk.desc": "合成一个脚本磁盘，用于存储脚本数据。",
    "advancement.integratedscripting.scripting_drive": "他们看见我驾驶",
    "advancement.integratedscripting.scripting_drive.desc": "合成一个脚本驱动器，以便将脚本加载到您的网络中。",
    "advancement.integratedscripting.terminal_bind": "脚本的崛起",
    "advancement.integratedscripting.terminal_bind.desc": "创建一个脚本，并将其绑定到变量卡。",
    "advancement.integratedscripting.terminal_display": "脚本的释放",
    "advancement.integratedscripting.terminal_display.desc": "在显示面板上显示一个脚本值。",
    "advancement.integratedscripting.terminal_open": "脚本的发现",
    "advancement.integratedscripting.terminal_open.desc": "打开脚本终端GUI。",
    "block.integratedscripting.mendesite": "门多石",
    "block.integratedscripting.scripting_drive": "脚本驱动器",
    "block.integratedscripting.scripting_drive.info": "将脚本磁盘暴露给网络。",
    "general.integratedscripting.description": "为集成动力学中的复杂操作创建脚本。",
    "gui.integratedscripting.create_file": "创建文件",
    "gui.integratedscripting.disk": "磁盘",
    "gui.integratedscripting.error.invalid_member": "选择一个有效的函数名或变量名在脚本编辑器中绑定。",
    "gui.integratedscripting.error.invalid_member.current": "当前选择：“%s”",
    "gui.integratedscripting.removal_dialog.delete": "删除",
    "gui.integratedscripting.removal_dialog.keep": "保留",
    "gui.integratedscripting.removal_dialog.message": "您想删除“%s”吗？",
    "gui.integratedscripting.removal_dialog.title": "确认脚本删除",
    "gui.integratedscripting.script": "脚本",
    "info_book.integratedscripting.advanced": "高级",
    "info_book.integratedscripting.advanced.external_editing": "外部编辑",
    "info_book.integratedscripting.advanced.external_editing.text1": "如果你可以访问运行单人或多人游戏的文件系统，你可以通过任何外部编辑器访问脚本文件。这允许你使用最喜欢的 IDE（如 Vi，但绝对不是 Emacs）创建脚本。",
    "info_book.integratedscripting.advanced.external_editing.text2": "脚本文件可以通过 &oworld/integratedscripting/&r 目录访问（单人世界请查看 &osaves/&r）。在这里，你将找到所有 &lScripting Disks&r 的目录，按其 ID 命名。在每个 &lScripting Disk&r 目录中，你将找到存储在该磁盘中的所有脚本文件。",
    "info_book.integratedscripting.advanced.external_editing.text3": "即使游戏正在运行，你也可以通过外部编辑器安全地修改这些脚本文件。外部保存文件后，它们将在游戏中自动更新，相关变量也将更新。",
    "info_book.integratedscripting.advanced.external_editing.text4": "如果外部编辑器支持此功能（现代 IDE 都支持），通过 &lScripting Terminal&r 修改脚本文件也会导致文件在外部编辑器中更新。",
    "info_book.integratedscripting.advanced.logging": "日志",
    "info_book.integratedscripting.advanced.logging.text1": "对于复杂的脚本，可能需要通过临时写入外部日志文件来调试它们。",
    "info_book.integratedscripting.advanced.logging.text2": "JavaScript 允许你调用 &oconsole.log()&r 和 &oconsole.error()&r 函数，将消息分别写入 &oStandard Out&r 和 &oStandard Error&r 输出流。",
    "info_book.integratedscripting.advanced.logging.text3": "调用这些函数时，日志消息将分别写入脚本相关的 &o.stdout&r 和 &o.stderr&r 文件。",
    "info_book.integratedscripting.advanced.logging.text4": "例如，如果你的脚本位于 &omyfile.js&r，日志消息将写入 &omyfile.js.stdout&r。",
    "info_book.integratedscripting.advanced.logging.text5": "这些 &o.stdout&r 和 &o.stderr&r 文件可以通过你的 &l脚本终端&r 或通过外部编辑访问。",
    "info_book.integratedscripting.advanced.logging.text6": "为了避免日志文件变得太大，它们的大小是有限制的。默认情况下，它们最多限制为 2096 行。如果你需要更多的行数，请咨询你的服务器管理员。",
    "info_book.integratedscripting.advanced.transient_storage": "瞬态存储",
    "info_book.integratedscripting.advanced.transient_storage.text1": "由于 Integrated Dynamics 基于函数式编程原则，状态跟踪主要不存在，除非通过外部方法（如 &lDelayer&r）。",
    "info_book.integratedscripting.advanced.transient_storage.text2": "由于 JavaScript 语言提供了函数式和命令式编程的混合，状态跟踪变得部分可行。",
    "info_book.integratedscripting.advanced.transient_storage.text3": "具体来说，如果你在函数外部声明一个可变变量（例如使用 &olet&r），你可以通过函数调用修改其值。",
    "info_book.integratedscripting.advanced.transient_storage.text4": "这样，你可以跟踪状态，例如计算函数调用的次数，或计算特定值的运行平均值。",
    "info_book.integratedscripting.advanced.transient_storage.text5": "这些变量的一个重要问题是它们的状态是瞬态的。具体来说，这意味着当网络中的变量卡被重新插入或服务器重启时，它们的值可能会被重置。",
    "info_book.integratedscripting.advanced.transient_storage.text6": "因此，你不能假设这些值始终存在。如果你需要持久化数据存储，最好使用 &lDelayer&r。",
    "info_book.integratedscripting.advanced.typescript": "TypeScript",
    "info_book.integratedscripting.advanced.typescript.text1": "TypeScript 是一种广为人知的 JavaScript 语言的超集，它增加了类型支持。这允许开发者通过定义变量和函数的类型来编写类型安全的 JavaScript。",
    "info_book.integratedscripting.advanced.typescript.text2": "虽然集成脚本仅支持纯 JavaScript，但所有可用的全局函数、值类型及其方法都有一个 TypeScript &otypings 文件&r。",
    "info_book.integratedscripting.advanced.typescript.text3": "当通过外部 IDE 编辑脚本时，可以加载此 typings 文件以创建类型安全的脚本。这仅推荐给了解 TypeScript 并知道如何使用它的人。",
    "info_book.integratedscripting.advanced.typescript.text4": "typings 文件位于 &oworld/integratedscripting/integratedscripting.d.ts&r（参见 &osaves/&r 用于单人游戏世界）。此文件在每次世界重启时会自动重新生成，因此你不应该手动修改此文件。",
    "info_book.integratedscripting.concepts": "概念",
    "info_book.integratedscripting.concepts.text1": "编辑、存储和向网络提供脚本需要三个元素：&lScripting Terminal&r、&lScripting Disk&r 和 &lScripting Drive&r。",
    "info_book.integratedscripting.concepts.text2": "&lScripting Disk&r 用于存储原始脚本内容，但本身无法执行任何操作。",
    "info_book.integratedscripting.concepts.text3": "&lScripting Drive&r 允许插入一个 &lScripting Disk&r，从而将其内容暴露给网络。",
    "info_book.integratedscripting.concepts.text4": "&lScripting Terminal&r 允许你查看、管理和编辑当前网络中由 &lScripting Drives&r 暴露的所有脚本。",
    "info_book.integratedscripting.concepts.text5": "以下将更详细地讨论这些元素。",
    "info_book.integratedscripting.disk": "脚本磁盘",
    "info_book.integratedscripting.disk.text1": "&lScripting Disks&r 负责存储脚本，并应插入到 &lScripting Drives&r 中。它们可以通过将一些 &lVariable Cards&r 与 &lMendesite&r 结合来创建。",
    "info_book.integratedscripting.disk.text2": "一旦 &lScripting Disk&r 插入到 &lScripting Drive&r 中，它们将获得一个唯一的数字标识符。此标识符将用于在 &lScripting Terminal&r 中修改此磁盘上的脚本。该标识符还用于将脚本元素链接到 &lVariable Cards&r。",
    "info_book.integratedscripting.disk.text3": "&lScripting Disk&r 可以安全地移动到另一个 &lScripting Drive&r 中而不会丢失脚本数据，即使在不同的网络中也是如此。但是，不在同一网络中的 &lVariable Cards&r 将开始抛出错误。",
    "info_book.integratedscripting.disk.text4": "&lScripting Disk&r 在存储大小上没有限制，但出于管理原因，建议将脚本拆分到多个磁盘上。",
    "info_book.integratedscripting.drive": "脚本驱动器",
    "info_book.integratedscripting.drive.text1": "每个 &lScripting Drive&r 是一个连接到你的 &lIntegrated Dynamics&r 网络的方块，它接受一个 &lScripting Disk&r，从而允许磁盘的脚本内容暴露给网络。",
    "info_book.integratedscripting.drive.text2": "它可以通过将一个 &lVariable Store&r 和一个 &lJukebox&r 与一些 &lScripting Disks&r 结合来制作。",
    "info_book.integratedscripting.introduction": "简介",
    "info_book.integratedscripting.introduction.text1": "&lIntegrated Scripting&r 是 &lIntegrated Dynamics&r 的一个扩展，用于创建脚本来处理 &lIntegrated Dynamics&r 网络中的复杂操作。默认情况下，该模组支持 JavaScript 脚本语言。",
    "info_book.integratedscripting.introduction.text2": "它允许你使用方便的脚本语法来定义 &lIntegrated Dynamics&r 的逻辑操作，而不是使用标准的可视化变量卡方法，后者在处理高级操作链时可能会变得繁琐。",
    "info_book.integratedscripting.introduction.text3": "例如，你可以轻松定义复杂的物品列表过滤器，如 &o\"可损坏的物品，属于模组 X，且只能用钻石镐挖掘的方块。\"&r 或 &o\"获取此列表中第二大的堆叠大小的物品。\"&r",
    "info_book.integratedscripting.introduction.text4": "使用此模组时建议具备基本的编程知识，但可以通过本书后面的教程进行学习。",
    "info_book.integratedscripting.materials": "材料",
    "info_book.integratedscripting.materials.text1": "在开始脚本编写之前，你需要一些 &lMendesite&r 块。这些块非常可塑，是存储和处理脚本的良好基础。&lMendesite&r 是通过在 &lDrying Basin&r 中结合 &lMenril Resin&r 和 &lAndesite&r 制成的。",
    "info_book.integratedscripting.section.main": "脚本",
    "info_book.integratedscripting.section.tutorials": "脚本教程",
    "info_book.integratedscripting.terminal": "脚本终端",
    "info_book.integratedscripting.terminal.text1": "&lScripting Terminal&r 是一个必须连接到你的 &lIntegrated Dynamics&r 网络的组件，用于管理该网络中存储在 &lScripting Disks&r 中的脚本。",
    "info_book.integratedscripting.terminal.text10": "之后，你可以将一个 &lVariable Card&r 插入屏幕右侧的插槽中，以将其绑定到此脚本成员。",
    "info_book.integratedscripting.terminal.text11": "此 &lVariable Card&r 现在可以在网络中其他地方使用，例如在 &lDisplay Panel&r 中显示变量成员，或在物品列表过滤器中使用函数成员作为操作符。",
    "info_book.integratedscripting.terminal.text12": "下一章将提供更多关于如何编写脚本的详细信息。",
    "info_book.integratedscripting.terminal.text2": "当右键点击放置的终端时，将显示一个简化的 &oIntegrated Development Environment&r (IDE)，你可以用它来编辑脚本。",
    "info_book.integratedscripting.terminal.text3": "在屏幕的左上角，你可以选择连接到网络的 &lScripting Disk&r 的标识符，之后该磁盘中存储的所有脚本文件将显示在屏幕下方的脚本文件列表中。",
    "info_book.integratedscripting.terminal.text4": "如果磁盘尚未包含任何脚本文件，你可以通过点击屏幕左下角的 \"+\" 按钮来创建它们。",
    "info_book.integratedscripting.terminal.text5": "屏幕左侧的脚本文件列表用于选择要编辑的脚本。点击一个脚本时，其可编辑内容将显示在屏幕右侧。",
    "info_book.integratedscripting.terminal.text6": "屏幕右侧的文本字段允许你编辑脚本文件的内容，每次修改后将自动保存。",
    "info_book.integratedscripting.terminal.text7": "虽然编辑器会进行有限的语法高亮，但它目前无法检测语法错误。语法错误将在通过 &lVariable Cards&r 执行脚本时报告。",
    "info_book.integratedscripting.terminal.text8": "为了将脚本成员用作 &lIntegrated Dynamics&r 的逻辑，你可以将其绑定到 &lVariable Card&r。",
    "info_book.integratedscripting.terminal.text9": "你可以通过在文本编辑器中选择脚本成员（例如变量名或函数名）来完成此操作。",
    "info_book.integratedscripting.tutorials.basics": "脚本的基础知识",
    "info_book.integratedscripting.tutorials.basics.text1": "&lMendesite&r 块是与脚本相关物品的基础材料。让我们使用 &l干燥盆地&r 来制作一些！",
    "info_book.integratedscripting.tutorials.basics.text2": "接下来，我们将使用这些 &lMendesite&r 块来制作一些 &l脚本磁盘&r 和 &l脚本驱动器&r。&l脚本磁盘&r 将能够存储脚本数据，&l脚本驱动器&r 将允许你将这些磁盘插入到你的网络中。",
    "info_book.integratedscripting.tutorials.basics.text3": "最后，让我们放置一个 &l脚本驱动器&r 并在其中存储一个 &l脚本磁盘&r。这将使我们能够在下一个教程中存储脚本。",
    "info_book.integratedscripting.tutorials.functions": "脚本函数",
    "info_book.integratedscripting.tutorials.functions.text1": "虽然通过 JavaScript 创建常量值可能很有趣，但这些脚本的真正强大之处在于创建 &ofunctions&r。",
    "info_book.integratedscripting.tutorials.functions.text2": "通过 JavaScript 创建的函数可以绑定到 &l变量卡&r 作为 &2Operators&0，然后可以在集成动力逻辑中正常使用。例如，你可以使用它们来定义集成管道的导出过滤器，或者计算复杂值，如列表中物品的中位数堆叠大小。",
    "info_book.integratedscripting.tutorials.functions.text3": "在本教程中，我们将创建一个接受一个 &8Item&0 参数并返回一个 &9Boolean&0 作为输出的函数。此函数将作为过滤器运算符，我们可以在过滤物品列表时使用它。",
    "info_book.integratedscripting.tutorials.functions.text4": "具体来说，我们将使用 &l库存读取器&r 读取物品列表，并使用我们新创建的函数进行 &l过滤&r。你可以通过在编辑器中选择函数并插入一个空的 &l变量卡&r 来将其绑定到 &l变量卡&r，这将将其存储为一个 &2Operator&0。",
    "info_book.integratedscripting.tutorials.functions.text5": "你可以自由使用任何实现过滤函数的方法来完成本教程。以下是一个有效的示例脚本，你可以自由复制。",
    "info_book.integratedscripting.tutorials.functions.text6": "为了完成教程，请在 &l显示面板&r 中显示过滤后的列表结果。",
    "info_book.integratedscripting.tutorials.functions.text7": "在本示例脚本中，你将看到你可以调用物品上的内置方法，如 &oisStackable()&r 和 &ostacksize()&r。更多关于可用方法的详细信息可以在完整手册中找到。",
    "info_book.integratedscripting.tutorials.introduction": "简介",
    "info_book.integratedscripting.tutorials.introduction.text1": "本节包含多个教程，帮助你学习 &l集成脚本&r，这是用于处理复杂操作的 &l集成动力&r 插件。",
    "info_book.integratedscripting.tutorials.terminal": "使用脚本终端",
    "info_book.integratedscripting.tutorials.terminal.text1": "在上一步中，我们创建并放置了一个 &l脚本磁盘&r 和 &l脚本驱动器&r。在本教程中，我们将看到如何实际 &owrite&r 脚本并将其绑定到 &l变量卡&r。",
    "info_book.integratedscripting.tutorials.terminal.text2": "首先，让我们制作一个 &l脚本终端&r，将其放置在连接到 &l脚本驱动器&r 的电缆上，并右键点击 &l脚本终端&r 以打开它。",
    "info_book.integratedscripting.tutorials.terminal.text3": "你将看到一个编辑器，可以通过它访问网络中所有可访问的 &l脚本磁盘&r 中存储的脚本文件。你可以通过点击屏幕左上角的箭头来切换不同的 &l脚本磁盘&r。",
    "info_book.integratedscripting.tutorials.terminal.text4": "在这个阶段，你的网络中还没有任何脚本文件，因此让我们通过点击屏幕左下角的 \"+\" 按钮来创建一个新文件。现在点击新文件以打开它，并点击屏幕右侧的文本框以编辑文件并编写 &oJavaScript&r 代码。",
    "info_book.integratedscripting.tutorials.terminal.text5": "为了保持简单，我们现在将创建一个常量值。让我们写一些像 &oconst myVar = 123;&r 这样的代码。",
    "info_book.integratedscripting.tutorials.terminal.text6": "作为最后一步，让我们通过将一个空的 &l变量卡&r 插入到屏幕右侧的插槽中，并用鼠标双击选择变量，将这个常量绑定到一个 &l变量卡&r 上。你的 &l变量卡&r 现在将绑定到这个常量值。你现在可以在网络中的任何地方使用这个 &l变量卡&r。让我们尝试在 &l显示面板&r 中显示它！",
    "info_book.integratedscripting.writing": "编写脚本",
    "info_book.integratedscripting.writing.functions": "函数",
    "info_book.integratedscripting.writing.functions.text1": "由于 &2Operators&0 是 Integrated Dynamics 逻辑中的一等公民，它们也可以作为 JavaScript 函数创建。",
    "info_book.integratedscripting.writing.functions.text2": "任何创建 JavaScript 函数的方法都可以用于创建 &2Operators&0，例如通过 &ofunction&r 关键字，或通过创建自定义的 lambda 表达式。",
    "info_book.integratedscripting.writing.functions.text3": "函数接受一定数量的参数，当通过 Integrated Dynamics 逻辑执行时，这些参数将接收常规的 Integrated Dynamics 值，并将其转换为 JavaScript 值。",
    "info_book.integratedscripting.writing.functions.text4": "将 JavaScript 函数绑定到 &lVariable Card&r 作为 &2Operator&0，与常量和变量一样，通过在脚本编辑器中选择函数成员名称并将其绑定到 &lVariable Card&r 来完成。此值现在可以在任何接受 &2Operator&0 的地方使用。",
    "info_book.integratedscripting.writing.functions.text5": "例如，你可以创建一个带有单个 &8Item&0 参数的函数，返回一个 &9Boolean&0，用作过滤 &2Operator&0，用于过滤从箱子中读取的物品列表。",
    "info_book.integratedscripting.writing.functions.text6": "以下是一些可以创建的不同类型的函数示例。",
    "info_book.integratedscripting.writing.globals": "全局函数",
    "info_book.integratedscripting.writing.globals.text1": "编写 JavaScript 代码时，你可以使用全局 &oidContext&r 变量通过 &oops&r 字段访问所有 Integrated Dynamics 运算符作为函数。这允许你在创建新运算符时使用内置的运算符。",
    "info_book.integratedscripting.writing.globals.text2": "例如，你可以编写一个 &8Item&0 过滤器，检查物品是否可堆叠且堆叠大小至少为 16，如下所示。",
    "info_book.integratedscripting.writing.globals.text3": "要了解要执行的运算符的名称，你可以通过 &lLogic Programmer&r 中的运算符提示或本书逻辑编程部分的运算符列表查看其全局名称。",
    "info_book.integratedscripting.writing.globals.text4": "由于通过 &oidContext&r 调用运算符可能会变得冗长，你可以选择将运算符存储在自定义的常量变量中，如第二个示例所示。或者，你可以使用 &o对象方法&r，这将在下一节中讨论。",
    "info_book.integratedscripting.writing.js": "JavaScript",
    "info_book.integratedscripting.writing.js.text1": "此模组允许使用 JavaScript 语法编写脚本。所有 ECMAScript (ECMA-262) 允许的功能都可用。",
    "info_book.integratedscripting.writing.js.text2": "请注意，Node.js 特有的功能（如 &orequire&r 和 &ofs&r）不可用。如果你习惯于开发 Node.js 应用程序，可以使用外部工具（如 Webpack）使其兼容。",
    "info_book.integratedscripting.writing.methods": "对象方法",
    "info_book.integratedscripting.writing.methods.text1": "为了减少全局函数的冗长，你可以使用 &lobject methods&r 编写更紧凑的代码。",
    "info_book.integratedscripting.writing.methods.text2": "对象值类型（如 &8Blocks&0、&8Items&0、&8Fluids&0 等）在 JavaScript 中使用时将附带 &lmethods&r。",
    "info_book.integratedscripting.writing.methods.text3": "对象方法只是普通的函数，但它们的第一个参数与对象值绑定。",
    "info_book.integratedscripting.writing.methods.text4": "例如，全局函数 &oitemstackStackable&r 接受一个 &8Item&0 参数并输出一个 &9Boolean&0。此函数在 &8Item&0 值上通过名称 &ostackable&r 可用，且不接受任何参数。",
    "info_book.integratedscripting.writing.methods.text5": "接受两个或更多参数的全局函数将在对象值上作为方法可用，所有参数向右移动一位。例如，全局函数 &oitemstackStrength&r 接受一个 &8Item&0 和一个 &8Block&0 参数，但也可以在 &8Items&0 上作为方法使用，仅接受一个 &8Block&0 参数。",
    "info_book.integratedscripting.writing.variables": "常量和变量",
    "info_book.integratedscripting.writing.variables.text1": "你熟悉的 &6Integers&0、&9Booleans&0、&8Items&0 等所有 Integrated Dynamics 值类型在 JavaScript 中都可用，反之亦然。",
    "info_book.integratedscripting.writing.variables.text2": "在 JavaScript 中创建值并使其在静态 &lVariable Card&r 值中可用的最直接方法，是使用 &olet&r 或 &oconst&r 定义变量成员。",
    "info_book.integratedscripting.writing.variables.text3": "&olet&r 定义的变量可以在脚本中重新赋值，例如计数器。&oconst&r 定义的变量不能重新赋值。",
    "info_book.integratedscripting.writing.variables.text4": "为了在 &lVariable Card&r 中使用此值，你需要在脚本编辑器中选择变量成员名称，然后在右侧插槽中插入一个空的 &lVariable Card&r。你现在可以像平常一样使用此 &lVariable Card&r，例如在 &lDisplay Panel&r 中可视化其值。",
    "info_book.integratedscripting.writing.variables.text5": "通过 JavaScript 创建变量主要在你需要创建复杂值时有用，这些值不容易通过 &lLogic Programmer&r 创建，例如具有特定值的长 &4Strings&0。以下是一些创建此类值的示例。",
    "item.integratedscripting.scripting_disk": "脚本磁盘",
    "item.integratedscripting.scripting_disk.bytes": "字节: %s",
    "item.integratedscripting.scripting_disk.id": "ID: %s",
    "item.integratedscripting.scripting_disk.info": "存储脚本。",
    "itemGroup.integratedscripting": "集成脚本",
    "operator.integratedscripting.error.no_graal_serialization": "集成脚本无法序列化",
    "operator.integratedscripting.integratedscript.basename": "集成脚本 %s",
    "operator.integratedscripting.integratedscript.graal": "Graal 函数",
    "parttype.integratedscripting.terminal_scripting": "脚本终端",
    "parttype.integratedscripting.terminal_scripting.info": "管理网络中脚本驱动器的脚本。",
    "script.integratedscripting.error.disk_not_in_network": "在当前网络中找不到ID为 %s 的磁盘。",
    "script.integratedscripting.error.invalid_network": "找不到有效的脚本网络。",
    "script.integratedscripting.error.invalid_type": "在磁盘 %s 的脚本 \"%s\" 中，成员 \"%s\" 预期暴露类型为 %s 的变量，但实际找到的是 %s。",
    "script.integratedscripting.error.member_not_in_network": "ID为 %s 的磁盘在脚本 \"%s\" 中不包含成员 \"%s\"。",
    "script.integratedscripting.error.path_not_in_network": "ID为 %s 的磁盘不包含脚本 \"%s\"。",
    "script.integratedscripting.error.script_exec": "在磁盘 %s 执行脚本 \"%s\" 中的成员 \"%s\" 时发生错误: %s",
    "script.integratedscripting.error.script_read": "在磁盘 %s 读取脚本 \"%s\" 时发生错误: %s",
    "script.integratedscripting.error.unsupported_language": "脚本 \"%s\" 的语言不受支持。",
    "script.integratedscripting.tooltip.disk": "磁盘ID: %s",
    "script.integratedscripting.tooltip.member": "成员: %s",
    "script.integratedscripting.tooltip.path": "脚本路径: %s",
    "valuetype.integratedscripting.error.translation.list_infinite": "无法将无限列表翻译成脚本语言。",
    "valuetype.integratedscripting.error.translation.nbt_unknown": "无法翻译类型为 %s 的NBT成员。",
    "valuetype.integratedscripting.error.translation.nbt_unmatched": "无法将字段 %s 解释为NBT。",
    "valuetype.integratedscripting.error.translation.proxyobject_putMember": "非法添加键“%s”到只读 %s",
    "valuetype.integratedscripting.error.translation.unknown_from_graal": "找不到从 %s Graal 值的翻译器。",
    "valuetype.integratedscripting.error.translation.unknown_to_graal": "找不到从 %s 值到 Graal 的翻译器。",
    "valuetype.integratedscripting.error.translation.unknown_to_graal_nbt": "在NBT翻译过程中找不到从 %s 值到 Graal 的翻译器。",
    "valuetype.integratedscripting.error.translation.unsupported_translateToNbt": "非法转换 %s “%s” 到NBT。"
}